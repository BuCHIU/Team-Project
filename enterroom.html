<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enter Room</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@latest/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
				}
			}
	</script>
    <script type="module">
        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let mixer;

        // 射線及鼠標
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const clock = new THREE.Clock();
        const container = document.getElementById('container');

        // 渲染
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        const pmremGenerator = new THREE.PMREMGenerator(renderer);

        // 場景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color("rgb(154, 192, 252)");
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(renderer), 0.04).texture;

        // 攝影機
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.set(1200, 400, 150);

        // 輔助座標軸
        const axesHelper = new THREE.AxesHelper(1000);
        scene.add(axesHelper);

        // const gui = new GUI();
        // const cameraParameters = {
        //     positionX: camera.position.x,
        //     positionY: camera.position.y,
        //     positionZ: camera.position.z,
        //     rotationX: camera.rotation.x,
        //     rotationY: camera.rotation.y,
        //     rotationZ: camera.rotation.z,
        //     fov: camera.fov,
        // };

        // gui.add(cameraParameters, 'positionX', -100, 100).name('Camera X').onChange(updateCamera);
        // gui.add(cameraParameters, 'positionY', -100, 100).name('Camera Y').onChange(updateCamera);
        // gui.add(cameraParameters, 'positionZ', -100, 100).name('Camera Z').onChange(updateCamera);
        // gui.add(cameraParameters, 'rotationX', -Math.PI, Math.PI).name('Rotation X').onChange(updateCamera);
        // gui.add(cameraParameters, 'rotationY', -Math.PI, Math.PI).name('Rotation Y').onChange(updateCamera);
        // gui.add(cameraParameters, 'rotationZ', -Math.PI, Math.PI).name('Rotation Z').onChange(updateCamera);
        // gui.add(cameraParameters, 'fov', 1, 179).name('Field of View').onChange(updateCamera);

        // 鼠標控制
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(1, 1, 1);
        controls.update();


        // 模型牆壁
        const loaderWall = new GLTFLoader();
        let modelWall;
        loaderWall.load('model/MAP.glb', function (gltf) {

            modelWall = gltf.scene;
            modelWall.position.set(0, 0, 0);
            modelWall.scale.set(1, 1, 1);
            scene.add(modelWall);

            animate();
        });

        // 動畫初始狀態
        let screenIsAnimating = false;
        // 模型投影幕
        const loaderScreen = new GLTFLoader();
        let modelScreen, mixerScreen, clipScreen, actionScreen;
        loaderScreen.load('model/projection/projection_screen.glb', function (gltf) {
            // console.log(gltf);

            modelScreen = gltf.scene;
            modelScreen.position.set(0, 0, 0);
            modelScreen.scale.set(1, 1, 1);
            scene.add(modelScreen);

            // 找到動畫
            clipScreen = THREE.AnimationClip.findByName(gltf.animations, "projection");
            if (clipScreen) {
                mixerScreen = new THREE.AnimationMixer(modelScreen);
                actionScreen = mixerScreen.clipAction(clipScreen);

                if (screenIsAnimating) {
                    actionScreen.play();
                }
            }

            animate();

        });

        // 模型投影機右
        const loaderProjectionR = new GLTFLoader();
        let modelProjectionR;
        loaderProjectionR.load('model/projection/R_projection.glb', function (gltf) {

            modelProjectionR = gltf.scene;
            modelProjectionR.position.set(0, 0, 0);
            modelProjectionR.scale.set(1, 1, 1);
            scene.add(modelProjectionR);

            animate();

        });

        // 模型投影機左
        const loaderProjectionL = new GLTFLoader();
        let modelProjectionL;
        loaderProjectionL.load('model/projection/L_projection.glb', function (gltf) {

            modelProjectionL = gltf.scene;
            modelProjectionL.position.set(0, 0, 0);
            modelProjectionL.scale.set(1, 1, 1);
            scene.add(modelProjectionL);

            animate();

        });

        // 模型椅子跟桌子
        const loaderCandT = new GLTFLoader();
        let modelCandT;
        loaderCandT.load('model/chair_table_01/CHaIR_and_table.glb', function (gltf) {

            modelCandT = gltf.scene;
            modelCandT.position.set(0, 0, 0);
            modelCandT.scale.set(1, 1, 1);
            scene.add(modelCandT);

            animate();

        });

        // 動畫初始狀態
        let chairIsAnimating = false;
        // 動畫已經播放了嗎
        let chairAnimationPlayed = false;
        // 模型會動椅
        const loaderChair = new GLTFLoader();
        let modelChair, mixerChair, clipChair, actionChair;
        loaderChair.load('model/chair_table_01/CHaIR_ani.glb', function (gltf) {
            console.log(gltf);

            modelChair = gltf.scene;
            modelChair.position.set(0, 0, 0);
            modelChair.scale.set(1, 1, 1);
            scene.add(modelChair);

            // 找到動畫
            clipChair = THREE.AnimationClip.findByName(gltf.animations, "CHAIR_ANI");
            if (clipChair) {
                mixerChair = new THREE.AnimationMixer(modelChair);
                actionChair = mixerChair.clipAction(clipChair);

                animate();
            }

        });

        // 讓縮放畫面的同時保持原有比例，更新畫面
        window.addEventListener('resize', onresize);
        window.onresize = function () {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        };

        // 畫面中的監聽事件-hover手＆點擊
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);

        // 鼠標hover-出現手手
        function onMouseMove(event) {
            // 更新鼠標的位置
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 更新 Raycaster
            raycaster.setFromCamera(mouse, camera);

            // 重新計算鼠標懸停的對象
            let intersectsProjectionR = raycaster.intersectObject(modelProjectionR);
            let intersectsChair = raycaster.intersectObject(modelChair);

            if (intersectsProjectionR.length > 0 || intersectsChair.length > 0) {
                document.body.style.cursor = 'pointer';
                // console.log('click');
            } else {
                document.body.style.cursor = 'auto';
            }
        }


        // 物件被點擊到要做什麼
        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);

            let intersectsProjectionR = raycaster.intersectObject(modelProjectionR);
            let intersectsChair = raycaster.intersectObject(modelChair);

            // 椅子播放動畫
            if (intersectsChair.length > 0) {
                if (mixerChair) {
                    if (actionChair.isRunning()) {
                        actionChair.stop();
                    } else {
                        actionChair.play();
                    }
                }
            }

            // 投影布幕降下來
            if (intersectsProjectionR.length > 0) {
                if (mixerScreen) {
                    if (actionScreen.isRunning()) {
                        actionScreen.stop();
                    } else {
                        actionScreen.play();
                    }
                }
            }
        }

        renderer.domElement.style.touchAction = 'none';


        function animate() {

            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (mixer) {
                mixer.update(delta);
            }

            if (modelScreen && mixerScreen) {
                mixerScreen.update(delta);
            }

            if (modelChair && mixerChair) {
                mixerChair.update(delta);
            }

            controls.update();

            raycaster.setFromCamera(mouse, camera);
            renderer.render(scene, camera);

        }


        animate();
    </script>

    
</body>
</html>